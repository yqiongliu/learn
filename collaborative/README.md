#协同过滤

利用用户和物品之间的联系,或者说利用用户的行为的算法，叫做协同过滤

具体的方法有：<br>
1基于邻域，比如接下来要讲的两种算法<br>
2隐语义模型(latent factor model)<br>
3基于图的随机游走算法(random walk on graph)<br>


##基于物品的协同过滤
原理：<br>
>给用户推荐和他喜欢的相似的产品

从上述描述中可见，关键的词是`用户喜欢`以及`相似`，即如何定义用户对一个商品的喜欢程度，以及如何定义物品之间的相似程度。<br>
物品之间的相似程度，又可以分为描述`相似`的特征，以及计算特征之间的距离的方式

可以用过用户行为建立物品之间的联系,(而非物品本身的属性)

算法：建立用户-物品倒排表。<br>
    
    获取商品的相似度表，和相似产品
    先对所有的 对上述结果做截断，取前k个;[对于用户不这样做，而只有物品这样，可能是因为用户数量大，重复少，二物品少，重复次数多]
    然后对于每个用户，的历史产品的相似产品取出，然后分数排列
    
    

应用：<br>
    对于详情页的推荐，主要使用和产品相关的同类型的推荐.<br>
    也就是首先建立用户-物品倒排，然后建立物品之间的相似度，然后根据相似度排序.<br>
    其实之后可以保留排序的分数，不过在详情页，因为只有一个种子商品，因此不要分数只要顺序也可以.<br>
    在详情页，除了考虑商品之间的联系，还可以考虑当前用户的特征，但应该其后考虑，主要是因为此时用户在此页面，想获取的是和当前商品更相关的内容。<br>
    对于猜你喜欢的推荐，就可以使用分数来做，因为这个时候种子商品很多，使用分数，可以提高重复看的类似的商品的权重，也可以考虑时间因子
        
特点：<br>
方便提供解释，比如喜欢物品a的用户，也可能喜欢物品b，<br>
适合物品较少的场景<br>
更加个性化，因为是推荐和用户喜欢的产品相似的产品<br>
物品相似度相对于用户的兴趣变化更慢一些，因此对于物品表的实时性可以不那么的高<br>
不需要更新物品表就可以支持新用户，但新物品需要更新物品表<br>

注意：<br>
热门用户对结果的影响，软惩罚和热惩罚，希望结果不要过于稠密<br>
归一化<br>
可以对列做归一化<br>


##基于用户的协同过滤
原理：<br>
>给用户推荐和他相似用户喜欢的产品

算法：<br>
    1 找到和用户相似的用户集合<br>
    2 在集合中，找到用户还未知的物品推荐给用户<br>
    
    获取用户相似度矩阵，和相似的用户;[相似用户是为了更快的获取么？不然只用矩阵不就好了]
    对于每一个用户，对和其相似用户列表中的每个用户，取出相似度
    对于相似的每一个用户，取出相似用户喜欢的产品，计算，
    最后排序出最喜欢的产品
用户相似：<br>
    根据用户的行为判断是否相似，则相似程度需要每个用户都计算。<br>
    复杂度高，且很多用户之间其实没有共有行为的物品。因此希望计算有共有行为的物品<br>
    可以使用倒排表。<br>
    倒排表：想知道两个用户之间有没有共有商品，需要遍历用户，很麻烦，则建立物品-用户的索引，拿到一个物品，则共有其的用户很方便的找到。<br>

物品到用户的倒排表：对每个物品都保存对其产生过行为的用户表
选择相似用户集合包含的人数，会影响结果，人数越多，越偏向热门产品

特点：<br>
适合用户较少的场景<br>
不利于提出解释<br>
更加社会化<br>
不更新用户表就可以发现新物品，但对于新用户则不太好推荐，需要更新用户表找到和它相似的用户

注意：<br>
热门商品对结果的影响<br>
相似程度的改进：考虑用户对于冷门产品的兴趣更能体现用户的喜好程度，对于一个商品除以它的热门程度的对数可以改善效果。<br>

##评价指标

真正 tp
真负 tn
假正 fp
假负 fn

则 <br>
推荐给用户的物品有tp+fp<br>
用户喜欢的物品tp+tn

召回率<br>
用户喜欢的物品中有多少被推荐了出来
tp/(tp+tn)

准确率<br>
推荐给用户的物品中有多少是用户喜欢的
tp/(tp+fp)

覆盖率[ag]<br>
所有被推荐的商品的并集占全局的比例

流行度[ag]<br>


读取数据

##测试
可以通过测试不同的数据，看如何选择特征离线效果更好

##总结
其实很多推荐的思路都是相似的，同样的思路，只是这些思路有很多具体实现的办法。
或者这是因为数据量太大，或者是因为业务的特殊性。


##python
dict 字典
数组
循环
条件
